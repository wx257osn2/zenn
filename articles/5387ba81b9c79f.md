---
title: "C++ã‚¯ã‚¤ã‚º: Workarounds å›ç­”ã¨è§£èª¬"
emoji: "ğŸ’¯"
type: "tech"
topics: ["cpp"]
published: true
---

# C++ã‚¯ã‚¤ã‚º: Workarounds å›ç­”ã¨è§£èª¬

ã“ã®è¨˜äº‹ã¯[C++ Advent Calendar 2020](https://qiita.com/advent-calendar/2020/cxx)ã®19æ—¥ç›®ã®è¨˜äº‹ã§ã™ï¼

Iã§ã™ï¼æ°—ã¥ã‘ã°ã‚‚ã†ä»Šå¹´2é€±é–“åˆ‡ã£ã¦ã¾ã™ã­â€¦

---

[9æ—¥ç›®ã®è¨˜äº‹](https://zenn.dev/wx257osn2/articles/42df3e03b9c343eb4a4d)ã®æƒ³å®šå›ç­”ã¨è§£èª¬ã§ã™ï¼
æœªèª­ã®æ–¹ã¯å…ˆã«9æ—¥ç›®ã®è¨˜äº‹ã‚’èª­ã‚“ã§è§£ã„ã¦ã¿ã‚‹ã¨æ¥½ã—ã‚ã‚‹ã‹ã¨æ€ã„ã¾ã™ï¼

---
.  
.  
.  
ä»¥  
ä¸‹  
å›  
ç­”  
ã¨  
è§£  
èª¬  
.  
.  
.  

---

## å›ç­”ã¨è§£èª¬

### 1. `a` : é–¢æ•°åã®å¤‰æ›´

ãƒ¡ãƒ³ãƒé–¢æ•°åãŒå¤‰ã‚ã£ãŸã®ã§ã„ãšã‚Œã§ã‚ã£ã¦ã‚‚å‘¼ã¹ã‚‹ãƒ©ãƒƒãƒ‘ãƒ¼é–¢æ•°ã‚’æ›¸ãã¾ã—ã‚‡ã†ï¼Œã¨ã„ã†å•é¡Œã§ã™ï¼
ä»Šå›ã®å•é¡Œã«ãŠã„ã¦ã¯ `awesome_type` ãŒ `a` ã¨ `a2` ã®2ã¤ã®ãƒ¡ãƒ³ãƒé–¢æ•°ã‚’åŒæ™‚ã«æŒã¤ã“ã¨ã¯ç„¡ã„ãŸã‚ï¼Œ `a` ã‚’æŒã£ã¦ã„ã‚‹å‹ã§ã¯ `a` ã‚’ï¼Œ `a2` ã‚’æŒã£ã¦ã„ã‚‹å‹ã§ã¯ `a2` ã‚’å‘¼ã¶ã‚ˆã†ãªãƒ©ãƒƒãƒ‘ãƒ¼é–¢æ•°ã‚’å®Ÿè£…ã™ã‚Œã°è‰¯ã„ã§ã—ã‚‡ã†ï¼
ã“ã‚Œã¯C++17ã§ã‚ã‚Œã°SFINAEã‚’ç”¨ã„ã¦å®Ÿè£…ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ï¼ `enable_if` ã‚’ç”¨ã„ãŸSFINAEã¯ä»¥ä¸‹ã®ã‚ˆã†ã«è¨˜è¿°ã—ã¾ã™ï¼

```cpp:C++17 å›ç­”1
template<typename T, std::enable_if_t<
  std::is_same<decltype(std::declval<T>().a(std::declval<std::size_t>())),
               int
	      >::value, std::nullptr_t> = nullptr>
static constexpr int a(const T& t, std::size_t index){
  return t.a(index);
}

template<typename T, std::enable_if_t<
  std::is_same<decltype(std::declval<T>().a2(std::declval<std::size_t>())), 
               int
	      >::value, std::nullptr_t> = nullptr>
static constexpr int a(const T& t, std::size_t index){
  return t.a2(index);
}
```

ã€Œå‘¼ã¹ã‚‹ã‹å‘¼ã¹ãªã„ã‹ã€ã®ã¿ã‚’èª¿ã¹ãŸã„å ´åˆã¯ï¼ŒSFINAEã®éš›æˆ»ã‚Šå€¤å‹ã®ãƒã‚§ãƒƒã‚¯ã¯å¿…ãšã—ã‚‚å¿…è¦ã‚ã‚Šã¾ã›ã‚“(ãŸã ã—ï¼Œä»¥ä¸‹ã®ã‚ˆã†ãªè¨˜è¿°ã®å ´åˆã¯ `awesome_type::a` ã¾ãŸã¯ `awesome_type::a2` ã®æˆ»ã‚Šå€¤å‹ãŒ `int` ã§ã¯ãªã„ `int` ã«æš—é»™å¤‰æ›å¯èƒ½ãªå‹ã«ãªã£ãŸéš›ã‚¨ãƒ©ãƒ¼ç„¡ã `int` ã«ã‚­ãƒ£ã‚¹ãƒˆã—ã¦è¿”ã™ã‚ˆã†ã«ãªã£ã¦ã—ã¾ã„ã¾ã™)ï¼

```cpp:C++17 å›ç­”2
namespace detail{

template<typename...>
struct detector_impl{
  using type = std::nullptr_t;
};
template<typename... Ts>
using detector = typename detector_impl<Ts...>::type;

}

template<typename T, detail::detector<
  decltype(std::declval<T>().a(std::declval<std::size_t>()))> = nullptr>
static constexpr int a(const T& t, std::size_t index){
  return t.a(index);
}

template<typename T, detail::detector<
  decltype(std::declval<T>().a2(std::declval<std::size_t>()))> = nullptr>
static constexpr int a(const T& t, std::size_t index){
  return t.a2(index);
}
```

ã¾ãŸï¼Œä»Šå›ã®ã‚ˆã†ã«ç§»è­²ã—ã¦ãã®ã¾ã¾çµæœã‚’è¿”ã™å ´åˆã¯ä»¥ä¸‹ã®ã‚ˆã†ã«æˆ»ã‚Šå€¤å‹éƒ¨åˆ†ã§SFINAEã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™ï¼SFINAEã¨ã—ã¦ã¯ã“ã‚ŒãŒä¸€ç•ªã‚·ãƒ³ãƒ—ãƒ«ï¼

```cpp:C++17 å›ç­”3
template<typename T>
static constexpr auto a(const T& t, std::size_t index) -> decltype(t.a(index)){
  return t.a(index);
}

template<typename T>
static constexpr auto a(const T& t, std::size_t index) -> decltype(t.a2(index)){
  return t.a2(index);
}
```

ä»–ã«ï¼Œconstexpr ifã‚’ç”¨ã„ã¦åˆ†å²ã™ã‚‹æ–¹æ³•ã‚‚ã‚ã‚Šã¾ã™ï¼
ã“ã®å ´åˆã¯SFINAE-friendlyãª `has_a` ãƒ¡ã‚¿é–¢æ•°ãŒå¿…è¦ã§ã™(`has_a` ãƒ¡ã‚¿é–¢æ•°ã¨ `std::enable_if` ã‚’ç”¨ã„ã¦å›ç­”2ç›¸å½“ã®è¨˜è¿°ã‚’è¡Œã†ã“ã¨ã‚‚å¯èƒ½ã§ã™)ï¼

```cpp:C++17 å›ç­”4
namespace detail{

template<typename T, typename = std::nullptr_t>
struct has_a : std::false_type{};
template<typename T>
struct has_a<T, detector<decltype(
  std::declval<T>().a(std::declval<std::size_t>())
)>> : std::true_type{};

}

template<typename T>
static constexpr int a(const T& t, std::size_t index){
  if constexpr(detail::has_a<T>::value)
    return t.a(index);
  else
    return t.a2(index);
}
```

ã¾ãŸï¼ŒC++20ã®å ´åˆã¯ã‚³ãƒ³ã‚»ãƒ—ãƒˆã‚’ç”¨ã„ã¦ä»¥ä¸‹ã®ã‚ˆã†ã«è¨˜è¿°ã§ãã¾ã™ï¼

```cpp:C++20 å›ç­”1
template<typename T>
requires(requires(const T& t){
  {t.a(std::declval<std::size_t>())} -> std::same_as<int>;
})
static constexpr int a(const T& t, std::size_t index){
  return t.a(index);
}

template<typename T>
requires(requires(const T& t){
  {t.a2(std::declval<std::size_t>())} -> std::same_as<int>;
})
static constexpr int a(const T& t, std::size_t index){
  return t.a2(index);
}
```

```cpp:C++20 å›ç­”2
template<typename T>
requires(requires(const T& t){{t.a(std::declval<std::size_t>())};})
static constexpr int a(const T& t, std::size_t index){
  return t.a(index);
}

template<typename T>
requires(requires(const T& t){{t.a2(std::declval<std::size_t>())};})
static constexpr int a(const T& t, std::size_t index){
  return t.a2(index);
}
```

```cpp:C++20 å›ç­”4
template<typename T>
static constexpr int a(const T& t, std::size_t index){
  if constexpr(requires(const T& t){{t.a(std::declval<std::size_t>())};})
    return t.a(index);
  else
    return t.a2(index);
}
```

ã‚³ãƒ³ã‚»ãƒ—ãƒˆï¼Œè¨˜è¿°ãŒæ¥½â€¦

### 2. `b` : æˆ»ã‚Šå€¤å‹ã®å¤‰æ›´

æ¬¡ã¯æˆ»ã‚Šå€¤å‹ãŒå¤‰ã‚ã£ãŸã®ã§å¤ã„ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã«åˆã‚ã›ã¾ã—ã‚‡ã†ï¼Œã¨ã„ã†å•é¡Œã§ã™ï¼
ã•ã¦ï¼Œ `sal_wrapper::b` ã§ã‚„ã‚ŠãŸã„ã“ã¨ã¯ä»¥ä¸‹ã§ã™ï¼

- `awesome_type::b` ã®æˆ»ã‚Šå€¤å‹ãŒãƒã‚¤ãƒ³ã‚¿ã®ã¨ã: ãã®ã¾ã¾è¿”ã™
- `awesome_type::b` ã®æˆ»ã‚Šå€¤å‹ãŒoptionalã®ã¨ã: å‘¼ã³å‡ºã—çµæœã® `value_or(nullptr)` ã‚’è¿”ã™

ã¤ã¾ã‚Šï¼Œ `awesome_type::b` ã®æˆ»ã‚Šå€¤å‹ãŒ `const int*` ã‹ `std::optional<const int*>` ã‹ã§SFINAEã—ã¦ã‚„ã‚Œã°è‰¯ã•ãã†ã§ã™ï¼

```cpp:C++17 å›ç­”
template<typename T, std::enable_if_t<
  std::is_same<decltype(std::declval<T>().b(std::declval<std::size_t>())),
               const int*
	      >::value, std::nullptr_t> = nullptr>
static constexpr const int* b(const T& t, std::size_t index){
  return t.b(index);
}

template<typename T, std::enable_if_t<
  std::is_same<decltype(std::declval<T>().b(std::declval<std::size_t>())),
               std::optional<const int*>
	      >::value, std::nullptr_t> = nullptr>
static constexpr const int* b(const T& t, std::size_t index){
  return t.b(index).value_or(nullptr);
}
```

ã‚ã‚‹ã„ã¯æˆ»ã‚Šå€¤å‹ãŒ `value_or` ãƒ¡ãƒ³ãƒé–¢æ•°ã‚’æŒã£ã¦ã„ã‚‹ã‹ï¼Œãªã©ã‚’ç¢ºèªã™ã‚‹ã“ã¨ã‚‚å¯èƒ½ã§ã™(ãŒï¼Œç›´æ„Ÿçš„ãªã‚³ãƒ¼ãƒ‰ã§ã‚‚ãªã„ã§ã™ã—ï¼Œé¿ã‘ãŸã»ã†ãŒæ‡¸å‘½ãªæ°—ãŒã—ã¾ã™)ï¼
åˆ¥è§£ã¨ã—ã¦ï¼ŒSFINAE-friendlyãªãƒ¡ã‚¿é–¢æ•°ã‚’ç”¨ã„ãŸconstexpr ifæ–‡ã«ã‚ˆã‚‹åˆ†å²ã‚‚æ‰‹ã§ã™ï¼

C++20ã§ã¯ã‚³ãƒ³ã‚»ãƒ—ãƒˆã‚’ç”¨ã„ã¦ã‚‚ã†å°‘ã—ç°¡æ½”ã«è¨˜è¿°ã§ãã¾ã™ï¼

```cpp:C++20 å›ç­”
template<typename T>
requires(requires(const T& t){
  {t.b(std::declval<std::size_t>())} -> std::same_as<const int*>;
})
static constexpr const int* b(const T& t, std::size_t index){
  return t.b(index);
}

template<typename T>
requires(requires(const T& t){
  {t.b(std::declval<std::size_t>())} -> std::same_as<std::optional<const int*>>;
})
static constexpr const int* b(const T& t, std::size_t index){
  return t.b(index).value_or(nullptr);
}
```

### 3. `c` : é–¢æ•°å®šç¾©ä½ç½®ã®å¤‰æ›´

é–¢æ•°ã®å®šç¾©ä½ç½®ãŒå¤‰ã‚ã£ãŸã®ã§é©åˆ‡ãªé–¢æ•°ã«ç§»è­²ã™ã‚‹ `c` ã‚’å®Ÿè£…ã—ãŸã„ï¼Œã¨ã„ã†å•é¡Œï¼
ã•ã¦ï¼Œã“ã®å•é¡Œã«ã¯å„ä»‹ãªç‚¹ãŒ2ã¤ã‚ã‚Šã¾ã™ï¼
1ã¤ã¯ï¼Œä¸Šè¨˜2å•ã§æ‰±ã£ãŸã‚ˆã†ã«ã‚ã‚‹å‹ `T` ãŒ(é™çš„/éé™çš„)ãƒ¡ãƒ³ãƒé–¢æ•°ã‚’æŒã¤ã‹ã©ã†ã‹ã‚’æ¤œæŸ»ã™ã‚‹ãƒ¡ã‚¿é–¢æ•°ã¯å®Ÿè£…ãŒå¯èƒ½ã§ã™ãŒï¼Œéãƒ¡ãƒ³ãƒé–¢æ•°ã®å­˜åœ¨æœ‰ç„¡ã¯SFINAE-friendlyãªå½¢ã§å®Ÿè£…ã§ããªã„ã¨ã„ã†ã“ã¨ã§ã™(å®Ÿè£…ã§ããªã„ã¨ç§ã¯æ€ã£ã¦ã‚‹ã‚“ã§ã™ãŒã‚‚ã—ã‹ã—ã¦æ–¹æ³•ã‚ã£ãŸã‚Šã™ã‚‹ã‚“ã§ã™ã‹ã­ï¼Ÿ)ï¼
å°¤ã‚‚ï¼Œã“ã®ç‚¹ã«ã¤ã„ã¦ã¯(å°‘ãªãã¨ã‚‚ä»Šå›ã®å•é¡Œã§ã¯ `awesome_type::c` ãŒç„¡ã‘ã‚Œã°éãƒ¡ãƒ³ãƒé–¢æ•°ã® `c` ãŒå­˜åœ¨ã™ã‚‹ãŸã‚) `awesome_type` ãŒ `c` ã‚’æŒã¤ã‹å¦ã‹ã®ãƒ¡ã‚¿é–¢æ•°ã‚’ç”¨ã„ã‚‹ã“ã¨ã§å¯¾å‡¦å¯èƒ½ã§ã™ï¼
ã‚‚ã†1ã¤ã¯ï¼Œéãƒ¡ãƒ³ãƒé–¢æ•°ã®ã‚·ãƒ³ãƒœãƒ«åã¯æ™®é€šã«è¨˜è¿°ã™ã‚‹ã¨ä¾å­˜åã«ãªã‚‰ãªã„ãŸã‚ï¼Œä»¥ä¸‹ã®ã‚ˆã†ãªè¨˜è¿°ã‚’ã™ã‚‹ã¨ `SUPER_AWESOME_LIBRARY_THAT_HAS_BREAKING_CHANGES_FREQUENTLY_VERSION` ãŒ `2` ã®æ™‚ `c` ãŒåå‰ç©ºé–“ `super_(ry` ã«å«ã¾ã‚Œãªã„ï¼Œã¨ã„ã†ã‚¨ãƒ©ãƒ¼ãŒå‡ºã¦ã—ã¾ã„ã¾ã™ï¼

```cpp
template<typename... Args,
         typename T = super_awesome_library_that_has_breaking_changes_frequently::awesome_type,
	 std::enable_if_t<ã„ã„æ„Ÿã˜ã®has_c<T>::value, std::nullptr_t> = nullptr>
static constexpr int c(Args&&... args){
  return T::c(std::forward<Args>(args)...);
}

template<typename... Args,
         typename T = super_awesome_library_that_has_breaking_changes_frequently::awesome_type,
	 std::enable_if_t<!ã„ã„æ„Ÿã˜ã®has_c<T>::value, std::nullptr_t> = nullptr>
static constexpr int c(Args&&... args){
  return super_awesome_library_that_has_breaking_changes_frequently::c(
           std::forward<Args>(args)...
	 );  //ã“ã“ã§ã‚¨ãƒ©ãƒ¼
}
```

ã“ã‚Œã¯ãªãœã‹ã¨è¨€ã†ã¨ï¼Œ `super_(ry ::c` ã¯templateå¼•æ•°ã®ä¾å­˜åã§ã¯ãªã„ãŸã‚ï¼ŒTwo phase lookupã®1å‘¨ç›®(ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–å‰)ã§lookupãŒèµ°ã£ã¦ã—ã¾ã†ãŸã‚ã§ã™ï¼
ãƒãƒ¼ã‚¸ãƒ§ãƒ³2ã«ãŠã„ã¦ä¸‹ã®é–¢æ•°ã¯ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã•ã‚Œãªã„ã“ã¨ã‚’æƒ³å®šã—ã¦ã„ã¾ã™ãŒï¼Œãã®å¦‚ä½•ã«é–¢ã‚ã‚‰ãšåå‰ç©ºé–“ `super_(ry` ã®ä¸‹ã« `c` ãŒå­˜åœ¨ã™ã‚‹ã‹ã©ã†ã‹ã®ç¢ºèªã¯è¡Œã‚ã‚Œã¦ã—ã¾ã†ã‚ã‘ã§ã™ï¼

ã•ã¦ï¼Œã“ã®å•é¡Œã®è§£æ³•ã¯ã–ã£ãã‚Šä»¥ä¸‹ã®2é€šã‚Šã¨ãªã‚Šã¾ã™ï¼

è§£æ³•1. ä¸Šè¨˜ã®ã‚ˆã†ã«ãƒ¡ã‚¿é–¢æ•°ã§å‘¼ã³åˆ†ã‘ã‚‹ï¼ã“ã®éš›ï¼Œéãƒ¡ãƒ³ãƒé–¢æ•°ã® `c` ã‚’ãªã‚“ã¨ã‹ã—ã¦ä¾å­˜åã«ã™ã‚‹
è§£æ³•2. `super_(ry` åå‰ç©ºé–“ã«ãƒãƒ¼ã‚¸ãƒ§ãƒ³2ç”¨ã® `c` ã‚’æ›¸ã„ã¦ã—ã¾ã†

#### æº–å‚™(C++17)

ã•ã¦ï¼ŒC++17ã®å ´åˆã„ãšã‚Œã®è§£æ³•ã«ãŠã„ã¦ã‚‚ã‚ã‚‹å‹ `T` ãŒé©åˆ‡ãªã‚·ã‚°ãƒãƒãƒ£ã®éãƒ¡ãƒ³ãƒé–¢æ•° `c` ã‚’æŒã¤ã‹ã‚’SFINAE-friendlyã« `bool` å€¤ã§å¾—ã‚‹æ‰‹æ®µãŒå¿…è¦ã§ã™ã®ã§ï¼Œå…ˆã«ãã¡ã‚‰ã‚’å®Ÿè£…ã—ã¾ã™ï¼
ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå¼•æ•°ã¨å¯å¤‰é•·å¼•æ•°ã®ç›¸æ€§ãŒæ‚ªã„ã®ã§ï¼Œã“ã“ã§ã¯å„ªå…ˆåº¦ã‚’æŒãŸã›ãŸé–¢æ•°ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰ã«ã‚ˆã‚‹SFINAEã‚’è¡Œã„ã¾ã™ï¼

```cpp:C++17 has_c
namespace detail{

template<std::size_t N>struct priority : priority<N-1>{};
template<>struct priority<0>{};

struct has_c_impl{
  template<typename T, typename... Args>
  static auto check(priority<1>, Args&&...)
    -> decltype(T::c(std::declval<Args>()...), std::true_type{});
  template<typename T, typename... Args>
  static auto check(priority<0>, Args&&...) -> std::false_type;
};

template<typename T, typename... Args>
using has_c = decltype(has_c_impl::check<T>(priority<1>{}, std::declval<Args>()...));

}
```

`priority<1>` å‹ã¯ `priority<0>` å‹ã®æ´¾ç”Ÿå‹ãªã®ã§ï¼Œ `priority<1>` ã‚’å¼•æ•°ã«æŒã¤é–¢æ•°ã®æ–¹ãŒã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰è§£æ±ºæ™‚ã«å„ªå…ˆã•ã‚Œã¾ã™ï¼
ã“ã‚Œã«ã‚ˆã‚Šã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰è§£æ±ºã®æ›–æ˜§ã•ã‚’è§£æ¶ˆã§ãã¾ã™ï¼

ãªãŠï¼ŒC++20ã®å ´åˆã¯ã‚³ãƒ³ã‚»ãƒ—ãƒˆã§ã­ã˜ä¼ã›ã¦ã„ã‘ã‚‹ã®ã§ä¸Šè¨˜ãƒ¡ã‚¿é–¢æ•°ã¯ä¸è¦ã§ã™ï¼

#### è§£æ³•1. `c` ã‚’ä¾å­˜åã«ã™ã‚‹

ã•ã¦ï¼Œä¸Šè¿°ã®é€šã‚Šæ™®é€šã«é–¢æ•°å‘¼ã³å‡ºã—ã‚’è¡Œã†ã¨ä¾å­˜åã«ã¯ãªã‚‰ãªã„ã‚ã‘ã§ã™ãŒï¼Œéãƒ¡ãƒ³ãƒé–¢æ•°å‘¼ã³å‡ºã—ã‚’ä¾å­˜åã«ã™ã‚‹æ–¹æ³•ï¼Œå®Ÿã¯ã‚ã‚Šã¾ã™ï¼
**é–¢æ•°å‘¼ã³å‡ºã—è§£æ±ºã‚’ADLã«å§”ã­ã‚‹** ã®ã§ã™ï¼

```cpp:C++17 è§£æ³•1
namespace detail{

template<typename... Args,
         typename T = super_awesome_library_that_has_breaking_changes_frequently::awesome_type,
	 std::enable_if_t<detail::has_c<T, Args...>::value, std::nullptr_t> = nullptr>
static constexpr int c_impl(Args&&... args){
  return T::c(std::forward<Args>(args)...);
}

template<typename... Args,
         typename T = super_awesome_library_that_has_breaking_changes_frequently::awesome_type,
	 std::enable_if_t<!detail::has_c<T, Args...>::value, std::nullptr_t> = nullptr>
static constexpr int c_impl(Args&&... args){
  using namespace super_awesome_library_that_has_breaking_changes_frequently; //cãŒå­˜åœ¨ã™ã‚‹ã‹ã¯ä¸æ˜ãªã®ã§åå‰ç©ºé–“å…¨ä½“ã‚’å°å…¥ã™ã‚‹
  return c(std::forward<Args>(args)...); //ADL
}

}

template<typename... Args>
static constexpr int c(Args&&... args){
  return detail::c_impl(std::forward<Args>(args)...);
}
```

å¼•æ•° `std::forward<Args>(args)` ãŒä¾å­˜åãªã®ã§ï¼ŒADLã«ã‚ˆã‚‹é–¢æ•°ãƒ«ãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’è¡Œãˆã°å‘¼ã³å‡ºã—é–¢æ•°ã¯ä¾å­˜åã¨ãªã‚Šã¾ã™ï¼ã‚„ã£ãŸãœï¼
ãŸã ã—ADLã§ `super_(ry ::c`ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹ä¿è¨¼ã¯å¿…ãšã—ã‚‚ãªã„ã®ã§ï¼Œã“ã®è§£æ³•ã¯é–¢æ•°åãŒæ¯”è¼ƒçš„uniqueãªã¨ãã«é™ã£ãŸã»ã†ãŒè‰¯ã„ã§ã—ã‚‡ã†ï¼
ã¾ãŸï¼Œå®Ÿè£…é–¢æ•°ã®åå‰ã‚’ `c` ã«ã—ã¦ã—ã¾ã†ã¨è‡ªå·±å†å¸°ã—ã¦ã—ã¾ã†ã®ã§å¿…ãš `c` ã§ãªã„åå‰(ä¸Šè¨˜ã§ã¯ `c_impl`)ã«ã—ã¾ã™ï¼

C++20ã®å ´åˆã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ï¼

```cpp:C++20 è§£æ³•1
namespace detail{

template<typename... Args,
         typename T = super_awesome_library_that_has_breaking_changes_frequently::awesome_type
>
requires(requires{{T::c(std::declval<Args>()...)};})
static constexpr int c_impl(Args&&... args){
  return T::c(std::forward<Args>(args)...);
}

template<typename... Args,
         typename T = super_awesome_library_that_has_breaking_changes_frequently::awesome_type
>
requires(!requires{{T::c(std::declval<Args>()...)};})
static constexpr int c_impl(Args&&... args){
  using namespace super_awesome_library_that_has_breaking_changes_frequently;
  return c(std::forward<Args>(args)...);
}

}

template<typename... Args>
static constexpr int c(Args&&... args){
  return detail::c_impl(std::forward<Args>(args)...);
}
```

#### è§£æ³•2. `super_(ry` åå‰ç©ºé–“ä¸Šã«ç›´æ¥ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰ã‚’ç”Ÿã‚„ã™

ã‚‚ã†1ã¤ã®è§£æ³•ã¯ï¼Œãƒãƒ¼ã‚¸ãƒ§ãƒ³2ç”¨ã® `c` ã‚’ `super_(ry` åå‰ç©ºé–“ä¸Šã«ç›´æ¥è¨˜è¿°ã—ã¦ã—ã¾ã†ã¨ã„ã†ã‚‚ã®ã§ã™ï¼
ã‚„ã‚„è¡Œå„€ã®æ‚ªã„è§£æ³•ã§ã™ãŒï¼Œ **åˆ¶ç´„** ã®ç¯€ã§

> `super_awesome_library_that_has_breaking_changes_frequently` åå‰ç©ºé–“å†…ã¯æ±šæŸ“ã—ã¦è‰¯ã„ã‚‚ã®ã¨ã™ã‚‹ï¼ 

ã¨ã—ãŸã®ã§å•é¡Œã‚ã‚Šã¾ã›ã‚“(ã¨ã„ã†ã‹ï¼Œã“ã®è§£æ³•ã®ãŸã‚ã«ã“ã®æ¡é …ã‚’åˆ¶ç´„ã«è¿½åŠ ã—ã¾ã—ãŸ)ï¼

ãƒãƒ¼ã‚¸ãƒ§ãƒ³2ç”¨ã® `c` ã¯ `awesome_type` ã«é™çš„ãƒ¡ãƒ³ãƒé–¢æ•° `c` ãŒã‚ã‚‹å ´åˆã¯ãã‚Œã«å‡¦ç†ã‚’ç§»è­²ã™ã‚‹ã‚ˆã†ãªé–¢æ•°ã§ã™ãŒï¼Œã“ã‚Œã‚’ `super_(ry` ã«ç›´æ¥è¨˜è¿°ã™ã‚‹ã¨

- ãƒãƒ¼ã‚¸ãƒ§ãƒ³1: `awesome_type` ã¯é™çš„ãƒ¡ãƒ³ãƒé–¢æ•° `c` ã‚’æŒãŸãªã„ã®ã§æœ¬æ¥ã®éãƒ¡ãƒ³ãƒé–¢æ•° `c` ãŒå‘¼ã³å‡ºã•ã‚Œã‚‹
- ãƒãƒ¼ã‚¸ãƒ§ãƒ³2: `super_(ry` åå‰ç©ºé–“ä¸Šã®é–¢æ•° `c` ã¯ `sal_wrapper` å´ã§å®Ÿè£…ã—ãŸã‚‚ã®ã®ã¿ãªã®ã§ï¼Œã“ã‚ŒãŒå‘¼ã°ã‚Œã‚‹ï¼ã“ã®éš›ï¼Œ `awesome_type` ã¯é™çš„ãƒ¡ãƒ³ãƒé–¢æ•° `c` ã‚’æŒã¤ã®ã§æ­£ã—ãå‡¦ç†ã‚’ç§»è­²ã™ã‚‹ï¼

ã¨ãªã‚Šï¼Œ `super_(ry ::c` ãŒãƒãƒ¼ã‚¸ãƒ§ãƒ³1ã§ã‚‚ãƒãƒ¼ã‚¸ãƒ§ãƒ³2ã§ã‚‚æœŸå¾…ã—ãŸã‚ˆã†ã«æŒ¯ã‚‹èˆã†ã‚ˆã†ã«ãªã‚Šã¾ã™ï¼
å•é¡Œæ–‡ã§ã¯ `sal_wrapper::c` ã‚’è¦æ±‚ã—ã¦ã„ã‚‹ã®ã§ï¼Œæœ€å¾Œã« `super_(ry ::c` ã‚’ `sal_wrapper` ä¸Šã« `using` ã—ã¦ã‚„ã‚Œã°é¡Œæ„ã‚’æº€ãŸã—ã¾ã™ï¼

```cpp:C++17 è§£æ³•2
namespace super_awesome_library_that_has_breaking_changes_frequently{

template<typename... Args,typename T = awesome_type,
  std::enable_if_t<
    sal_wrapper::detail::has_c<T, Args...>::value,
  std::nullptr_t> = nullptr>
static constexpr int c(Args&&... args){
  return T::c(std::forward<Args>(args)...);
}

}

namespace sal_wrapper{

using super_awesome_library_that_has_breaking_changes_frequently::c;

}
```

C++20ã§ã¯ä»¥ä¸‹ã¨ãªã‚Šã¾ã™ï¼

```cpp:C++20 è§£æ³•2
namespace super_awesome_library_that_has_breaking_changes_frequently{

template<typename... Args, typename T = awesome_type>
requires(requires(const T& t){{T::c(std::declval<Args>()...)};})
static constexpr int c(Args&&... args){
  return T::c(std::forward<Args>(args)...);
}

}

namespace sal_wrapper{

using super_awesome_library_that_has_breaking_changes_frequently::c;

}
```

### 4. `d` : ä»®æƒ³é–¢æ•°ã®å¼•æ•°ã®å¤‰æ›´

ä»®æƒ³é–¢æ•°ã®å¼•æ•°ãŒå¢—ãˆãŸã®ã§ï¼Œãã‚Œã‚’éš è”½ã§ãã‚‹ã‚ˆã†ãªè¦ªã‚¯ãƒ©ã‚¹ã‚’ä½œã‚‹å•é¡Œï¼
ãƒãƒ¼ã‚¸ãƒ§ãƒ³1ã®å ´åˆã¯ `sal_wrapper::excellent_base` ãŒ `super_(ry ::excellent_type` ã‚’æŒ‡ã›ã°è‰¯ãï¼Œ
ãƒãƒ¼ã‚¸ãƒ§ãƒ³2ã®å ´åˆï¼Œ `void d(int, super_flags)` ãŒ `void d(int)` ã«ç§»è­²ã•ã‚Œã‚‹ã‚ˆã†ãª `excellent_base` ã‚’å®Ÿè£…ã—ï¼Œ
ã“ã‚Œã‚‰ã‚’ `super_(ry ::excellent_type::d` ã®ã‚·ã‚°ãƒãƒãƒ£ã«å¿œã˜ã¦åˆ‡ã‚Šæ›¿ãˆã‚‹ã‚ˆã†ã«ã—ã¾ã™ï¼

```cpp:C++17 å›ç­”
namespace detail{

template<typename T>
struct excellent_base : T{
  virtual void d(int) = 0;
  virtual void d(
      int value,
      super_awesome_library_that_has_breaking_changes_frequently::super_flags
  )override{
    this->d(value);
  }
};

template<typename T>
class d_with_super_flags{
  template<typename U>
  static std::true_type impl(
    decltype(std::declval<U>().d(
      std::declval<int>(),
      std::declval<super_awesome_library_that_has_breaking_changes_frequently::super_flags>()
    ))*
  );
  template<typename U>
  static std::false_type impl(
    decltype(std::declval<U>().d(
      std::declval<int>()
    ))*
  );
 public:
  static constexpr bool value = decltype(impl<T>(nullptr))::value;
};

template<typename T>
using excellent_base_switcher_t = std::conditional_t<
  d_with_super_flags<T>::value,
  excellent_base<T>,
  T
>;

}

using excellent_base = detail::excellent_base_switcher_t<
  super_awesome_library_that_has_breaking_changes_frequently::excellent_type
>;
```

`excellent_base` ã¯ `excellent_type` ã®æ´¾ç”Ÿå‹ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚‹ã®ã§ï¼Œãƒãƒ¼ã‚¸ãƒ§ãƒ³2ã® `excellent_type` ã‚’å¿µé ­ã«2å¼•æ•°ã® `d` ã‚’æŒã¤ã¨ä»®å®šã—ã¦è¨˜è¿°ã—ï¼Œ1å¼•æ•°ã® `d` ã¯ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«å‘ã‘ã¦ç´”ç²‹ä»®æƒ³é–¢æ•°ã«ã—ã¦ãŠãã¾ã™ï¼
ç›´æ¥ `excellent_type` ã‚’ç¶™æ‰¿ã™ã‚‹ã®ã§ã¯ãªãï¼Œtemplateå¼•æ•°ã®å‹ã‚’ç¶™æ‰¿ã™ã‚‹ã“ã¨ã§ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã¾ã§å®Ÿéš›ã®ãƒ¡ãƒ³ãƒé–¢æ•°ã®ã‚·ã‚°ãƒ‹ãƒãƒ£ã®ãƒã‚§ãƒƒã‚¯ã‚’é…å»¶ã•ã›ã¾ã™ï¼
ã‚ã¨ã¯ãƒ¡ãƒ³ãƒé–¢æ•° `d` ã®ã‚·ã‚°ãƒãƒãƒ£ãŒãƒãƒ¼ã‚¸ãƒ§ãƒ³2ã®ã‚‚ã®ã‹ã©ã†ã‹ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹ãƒ¡ã‚¿é–¢æ•°ã‚’ä½¿ã£ã¦ `std::conditional` ã§å‹ã‚’ã‚¹ã‚¤ãƒƒãƒã—ã¾ã™ï¼

C++20ã§ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ï¼

```cpp:C++20 å›ç­”
namespace detail{

template<typename T>
struct excellent_base : T{
  virtual void d(int) = 0;
  virtual void d(
      int value,
      super_awesome_library_that_has_breaking_changes_frequently::super_flags
  )override{
    this->d(value);
  }
};

template<typename T>
using excellent_base_switcher = std::conditional_t<
  requires(T& t){
    {t.d(std::declval<int>(),
         std::declval<super_awesome_library_that_has_breaking_changes_frequently::super_flags>())
    } -> std::same_as<void>;
  },
  excellent_base<T>, T
>;

}

using excellent_base = detail::excellent_base_switcher<
  super_awesome_library_that_has_breaking_changes_frequently::excellent_type
>;
```

ãŸã ã—ï¼Œg++ 10ã§ã¯using aliasã¨ `std::same_as` ã®ä½µç”¨ãŒã‚¨ãƒ©ãƒ¼ã«ãªã‚‹ãƒã‚°ãŒã‚ã‚‹ãŸã‚ï¼Œ `excellent_base_switcher` ã«ã¤ã„ã¦ä»¥ä¸‹ã®ã„ãšã‚Œã‹ã®ã‚ˆã†ãªworkaroundãŒå¿…è¦(g++ 11ã§ã¯ä¿®æ­£æ¸ˆã¿ã®æ¨¡æ§˜)ï¼

```cpp:workaround1 std::conditionalã®æ´¾ç”Ÿå‹ã¨ã—ã¦ãŠã
namespace detail{

template<typename T>
struct excellent_base_switcher : std::conditional<
  requires(T& t){
    {t.d(std::declval<int>(),
         std::declval<super_awesome_library_that_has_breaking_changes_frequently::super_flags>())
    } -> std::same_as<void>;
  },
  excellent_base<T>, T
>{};

}

using excellent_base = detail::excellent_base_switcher<
  super_awesome_library_that_has_breaking_changes_frequently::excellent_type
>::type; //ã“ã“ã§typeã‚’ã¨ã‚‹
```

```cpp:workaround2 same_asã‚’ä½¿ã‚ãšã«æˆ»ã‚Šå€¤å‹ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹
template<typename T>
using excellent_base_switcher = std::conditional_t<
  requires(T& t){
    {t.d(std::declval<int>(),
         std::declval<super_awesome_library_that_has_breaking_changes_frequently::super_flags>())
    };
    std::is_void<
      decltype(t.d(
        std::declval<int>(),
	std::declval<super_awesome_library_that_has_breaking_changes_frequently::super_flags>()
      ))
    >::value;
  },
  excellent_base<T>, T
>;
```

### 5. `hypers` : rangeå¯¾å¿œ

ã„ã„æ„Ÿã˜ã®rangeã‚’ä½œã‚‹å•é¡Œï¼
ã„ã„æ„Ÿã˜ã®rangeã‚’ä½œã‚Šï¼Œ `excellent_type::access_hyper_data` ã‚„ `excellent_type::hypers` ã¨ã„ã£ãŸãƒ¡ãƒ³ãƒé–¢æ•°ã®æœ‰ç„¡ã«å¿œã˜ã¦ã„ã„æ„Ÿã˜ã®rangeã‚’è¿”ã—ãŸã‚Š `excellent_type::hypers` ã‚’ãã®ã¾ã¾è¿”ã—ãŸã‚Šã™ã‚Œã°OKã§ã™ï¼

```cpp:C++17 å›ç­”
namespace detail{

template<typename T>
struct hyper_range{
  T* t;
 public:
  class iterator{
    class accessor{
      T* t;
      std::size_t index;
     public:
      accessor() = default;
      accessor(T* ptr, std::size_t ind) : t{ptr}, index{ind}{}
      accessor(const accessor&) = default;
      accessor(accessor&&) = default;
      accessor& operator=(const accessor&) = default;
      accessor& operator=(accessor&) = default;
      const std::string& access()const{
        return t->access_hyper_data(index);
      }
      friend class iterator;
    }a;
   public:
    using difference_type = std::ptrdiff_t;
    using value_type = accessor;
    using iterator_category = std::bidirectional_iterator_tag;
    iterator() = default;
    iterator(T* ptr, std::size_t ind) : a{ptr, ind}{}
    iterator(const iterator&) = default;
    iterator(iterator&&) = default;
    iterator& operator=(const iterator&) = default;
    iterator& operator=(iterator&&) = default;
    iterator& operator++(){
      ++a.index;
      return *this;
    }
    iterator operator++(int){
      iterator it = *this;
      ++*this;
      return it;
    }
    iterator& operator--(){
      --a.index;
      return *this;
    }
    iterator operator--(int){
      iterator it = *this;
      --*this;
      return it;
    }
    bool operator==(const iterator& rhs)const{
      return a.index == rhs.a.index;
    }
    bool operator!=(const iterator& rhs)const{
      return !(*this == rhs);
    }
    const accessor& operator*()const{return a;}
    const accessor* operator->()const{return &a;}
  };
  constexpr explicit hyper_range(T* ptr):t{ptr}{}
  iterator begin()const{return iterator{t, 0u};}
  iterator end()const{return iterator{t, t->hyper_size()};}
};

}

template<typename T, std::enable_if_t<
  std::is_same<
    decltype(std::declval<T>().access_hyper_data(std::declval<std::size_t>())),
    const std::string&
  >::value, std::nullptr_t> = nullptr>
static detail::hyper_range<const T> hypers(const T& t){
  return detail::hyper_range<const T>{&t};
}

template<typename T, std::enable_if_t<
  std::is_same<
    decltype(std::declval<T>().hypers().begin()->access()),
    const std::string&
  >::value,std::nullptr_t> = nullptr>
static auto hypers(const T& t){
  return t.hypers();
}
```

```cpp:C++20 å›ç­”
namespace detail{

template<typename T>
struct hyper_range{
  T* t;
 public:
  class iterator{
    class accessor{
      T* t;
      std::size_t index;
     public:
      accessor() = default;
      accessor(T* ptr, std::size_t ind) : t{ptr}, index{ind}{}
      accessor(const accessor&) = default;
      accessor(accessor&&) = default;
      accessor& operator=(const accessor&) = default;
      accessor& operator=(accessor&&) = default;
      const std::string& access()const{
        return t->access_hyper_data(index);
      }
      friend class iterator;
    }a;
   public:
    using difference_type = std::ptrdiff_t;
    using value_type = accessor;
    using iterator_concept = std::bidirectional_iterator_tag;
    iterator() = default;
    iterator(T* ptr, std::size_t ind) : a{ptr, ind}{}
    iterator(const iterator&) = default;
    iterator(iterator&&) = default;
    iterator& operator=(const iterator&) = default;
    iterator& operator=(iterator&&) = default;
    iterator& operator++(){
      ++a.index;
      return *this;
    }
    iterator operator++(int){
      iterator it = *this;
      ++*this;
      return it;
    }
    iterator& operator--(){
      --a.index;
      return *this;
    }
    iterator operator--(int){
      iterator it = *this;
      --*this;
      return it;
    }
    bool operator==(const iterator& rhs)const{
      return a.index == rhs.a.index;
    }
    bool operator!=(const iterator& rhs)const{
      return !(*this == rhs);
    }
    const accessor& operator*()const{return a;}
    const accessor* operator->()const{return &a;}
  };
  constexpr explicit hyper_range(T* ptr):t{ptr}{}
  iterator begin()const{return iterator{t, 0u};}
  iterator end()const{return iterator{t, t->hyper_size()};}
};

}

template<typename T>
requires(requires(const T&){
  {std::declval<T>().access_hyper_data(std::declval<std::size_t>())}
    -> std::same_as<const std::string&>;
})
static detail::hyper_range<const T> hypers(const T& t){
  return detail::hyper_range<const T>{&t};
}

template<typename T>
requires(requires(const T&){
  {std::declval<T>().hypers().begin()->access()}
    -> std::same_as<const std::string&>;
})
static auto hypers(const T& t){
  return t.hypers();
}

}
```

---

~~æœ€å¾Œã®æ–¹ç–²ã‚Œã¦é›‘ã«ãªã£ãŸãªï¼Ÿã¾ã5å•ç›®ã¯èªã‚‹ã“ã¨ã‚‚ç‰¹ã«ãªã„ã—ãˆãˆã‹â€¦~~

æ˜æ—¥ã‚‚ç§ã§ã™ï¼ã‚ˆã‚ã—ããŠé¡˜ã„ã—ã¾ã™ï¼ã¾ã ä½•ã‚‚æ›¸ã„ã¦ã¾ã›ã‚“ãŒâ€¦
